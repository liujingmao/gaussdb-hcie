#### 高斯IE 论述题

##### (1) 权限管理模型RBAC和ABAC区别

+ **RBAC**： 基于角色的访问控制，角色通常是指具有某类共同特征的一组人，例如：部门、地点、资历、级别、工作职责等。在系统初始时Admin根据业务需要创建多个拥有不同权限组合的角色，当需要赋予绑定某个用户权限的时候，把用户归到相应角色里即可赋予需要的权限 
+ **ABAC**：不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是通过动态计算一个或者一组属性来判断是否满足某种条件来进行授权判断(可以编写简单的逻辑)。属性通常来说分为四类：用户属性，环境属性，操作属性和对象属性，所以理论上能够实现非常灵活的权限控制，几乎能够满足所有类型的需求。权限判断需要实时执行，规则过多会导致性能问题。
+ 两者区别：RBAC基于用户角色提供对资源或者信息的访问，而ABAC提供基于用户，环境或者资源属性的访问权限。

##### (2) 数据库数据加密方式有哪些，至少3种

+ 函数加密: 字段级别，通过调用函数，如**md5()**等函数对传入参数进行加密，业务感知加密，不支持密文条件安全，数据在会话中临时解密，数据库无法自动解密，防止高权限账号窃取数据；
+ 透明加密：表级别，数据在文件落盘时加密，对用户及上层使用**SQL**的应用不感知，对于需要加密的表创建时通过**TDE**参数指定加密算法，数据库无感知，内存明文处理，防止基于物理磁盘的数据窃取，**TDE**密钥管理分三层，分别是根密钥、主密钥和数据加密密钥；
+ 全密态：字段级，支持密态等值查询，数据库无法解密，防止运维、管理和高权账户等窃取隐私数据，在业务中仅在**DDL**层做了扩展，在**create table**或者**alter table**新增加列时可以将列设置为加密列，给需要加密的列绑定列加密密钥即可，**DML**操作于其他表一致，但需要以密态方式创建客户端连接才可以，如果是非密态模式，那么查询看到的数据是密文，未指定加密的列均明文处理，密钥管理分三层，分别是根密钥、主密钥和列加密密钥，密钥均存储于**GaussDB Client**中，减少攻击面。总之，函数加密，是用户把密钥给到数据库，数据库在执行过程中函数时做一个加密动作，在数据库里加密。透明加密是数据库自己找一个密钥，在磁盘落盘时做数据加密，是磁盘加密。全密态加密是客户找到密钥之后先把数据加密，再把数据交给数据库，全生命周期都是密文。
+ 客户端和服务端**SSL**通信加密：**SSL**加密支持对称加密、非对换加密、对称加密算法指的是加密和解密使用相同的密钥，特点是算法公开、加密和解密速度快，效率高；非对称加密算法包含两个密钥，公钥和私钥是一对，加密和解密使用不同的密码，特点是算法复杂度高、安全性更高、性能较对称加密差。
+ 常见的算法为**AES**、**DES**、**MD5**和**SM4

##### (3) 使用存储过程的优点，至少写4点

+ ###### 存储过程极大地提高**SQL**语言的**灵活性**，可以完成**复杂的运算**

+ ###### 可以保障数据的**安全性**和**完整性**

+ ###### **极大地改善SQL语句的性能**，在运行存储过程之前，数据库已经对其语法和句法分析，并给出优化执行方案。这种已经编译好的过程极大地改善了SQL的执行性能

+ ###### **可以降低网络的通信量**，客户端通过调用存储过程只需要存储过程名和传入相关参数即可，与传输SQL相比自然数据量少很多

##### (4) 存储过程和函数的区别

+ ###### **含义不同(概念不同)**

  + ###### **存储过程**: 是SQL语句和可控制流程语句的**预编译集合**

  + ###### **函数**:是有一个或者多个SQL语句组成的**子程序** 

+ ###### **使用条件不同**

  + ###### **存储过程**： 可以在单个存储过程中执行一系列SQL语句。而且可以从自己的存储过程内引入其他存储过程，这可以简化一系列复杂的语句；

  + ###### **函数**：自定义函数有着诸多限制，有许多语句不能使用，例如**临时表**

+ ###### **执行方式不同**

  + ###### **存储过程**：可以返回参数，如记录集，存储过程声明时不需要返回类型

  + ###### **函数**：只能返回值或者是表对象，声明时需要描述**(声明)返回类型**，且函数中必须包含一个有效的**return**语句。

##### (5) 存储过程和匿名块的区别,写2个

+ ###### **存储过程** 是经过预编译并存储在数据库的，可以重复使用的可控制流程语句的集合；而匿名块是未存储在数据库中，从应用程序缓存区擦除后，除非应用重新输入代码，否则无法重启执行；

+ ###### **匿名块** 不需要命名，存储过程必须申明名字


##### (6) 全量备份、差分备份和增量备份的区别

+ 全量备份：在备份全部数据时，全量备份需要的时间最长，因为需要备份的数据量大。但是，这种备份方式在恢复速度最快，只需要一个磁盘可恢复丢失的数据，此外，由于需要备份的数据量较大，全量备份可能会占用比较多的存储空间；
+ 差分备份：差分备份是备份自上一次完全备份之后有变化的数据。这种备份方式相较于全量备份，备份数据量少，因此 备份所需要的时间较少。同时，由于只需要对第一次全备份和最后一次差异备份进行恢复，所以恢复时间也相对较快。但是，差分备份的数据恢复过程相较于全量备份和增量备份较为复杂；
+ 增量备份：增量备份是备份上一次备份(包括完全备份、差异备份、增量备份)之后有变化的数据。这种备份方式最大的优点是没有重复的备份数据，因此备份的数据量并不大，备份所需要的时间很短。但是，增量备份的数据恢复比较麻烦，需要所有的增量备份数据才能进行恢复；
+ 三种备份所备份的数据量不一样，所需要的时间也不一样，全量备份不需要依赖于其他任意备份，差分备份和增量备份需要依赖于全量备份。

##### (7) 全量备份、差分备份和增量备份数据集大小关系

+ 全量备份的数据是最大的，是执行备份时刻的所有数据；
+ 差分备份的数据虽然没有全量大，但相比较增量更大，因为差分备份的是相较于上次全量备份有变更的数据；
+ 增量备份的数据集大小是有三种备份中最小的，因为增量备份只与上一次备份相比较，无论上一次备份是全量、差分还是增量都可以；

##### (8) 数据可以恢复到指定时间点，使用什么技术实现，与物理文件备份相比，这种依赖哪个关键文件

+ 将数据恢复到指定时间点需要基于PITR技术实现，主要需要依赖于全量备份文件、增量备份文件和WAL日志；
+ 恢复时先根据指定时间点找到最近上次全量备份进行恢复，然后逐个恢复这次全量后的增量备份，直到恢复到时间点前最后一次增量备份，从最后一次增量备份到时间点这段时间数据通过WAL日志进行恢复。

##### (9) 什么是数据库事务，介绍GaussDB数据库事务管理的实现

+ 事务是单个逻辑单元执行的一系列操作，这些操作作为一个整体一起向系统提交要么执行，要么不执行。事务是一个不可分割的工作逻辑单元，GaussDB支持事务的ACID特性(**原子性**(atomicity)，**一致性(consistancy)**,**隔离性(isolation)**,**持久性(duration)**)。
+ **GaussDB**基于**MVCC**(多版本并发控制)并结合两阶段锁的方式进行事务管理，其特点是**读写之间不阻塞**。**SELECT**是纯读操作，**UPDATE**和**DELETE**读写操作。在准备阶段就会把提交操作所需要的信息和资源全部写入磁盘，进行持久化，提交阶段根据之前准备好的提交信息和资源，故障或者执行失败发生在准备阶段和提交阶段之间时，事务的最终状态为回滚。
+ **GaussDB**基于**GTM**组件协助管理分布式事务，采用多版本并发控制**MVCC**机制。**GaussDB**提供了不同的**GTM**模式，**GTM-Lite**和**GTM-Free**。在**GTM-Lite**模式下，中心事务处理节点的压力得到减轻，事务处理流程进一步优化，**GTM**的性能和并发瓶颈得到缓解，可实现强一致性；在**GTM-Free**模式下，中心事务管理节点不再参与事务管理，消除了**GTM**单点瓶颈，可以达到更高的事务处理性能，但不支持强一致性，仅支持最终一致性。

##### (10) GaussDB数据库有哪些事务隔离级别，并说明含义

+ **READ COMMITED**: 读已提交隔离级别，事务只能讲到已提交的数据而不会读未提交的数据，这是默认值 。在读已提交模式里，每个新的命令都是从一个新的快照开始的，而这个快照包含所有到该时刻为止已经提交的事务，因此同一事务中后面的命令将看到任何已经提交的其它事务的结果(效果)。这里关心的问题是在单个命令里是否看到数据库里完全一致的视图。
+ **REPEATABLE READ**: 事务可以重复读隔离级别，事务只能讲到事务开始之前已经提交的数据，不能读取到未提交的数据 以及事务执行期间其它并发事务提交的修改(**但是，查询能够查到自身所在事物中先前更新的执行结果，即使先前更新尚未提交**)。可重复读事务中的查询看到的是事务开始时的快照，不是该事务内部当前查询开始时的快照，就是说，单个事务内部的**SELECT**命令总是查看到同样的数据，查看不到自身事务开始之后其他并发事务修改后提交的数据。

##### (11) 输出命令，启动事务，事务隔离级别为读已提交，只读模式

+ 启动事务:  **start transaction**

+ 设置隔离级别为只读模式

  **set local transaction isolation level read committed read only**

+ 结束事务

  **commit;**








### 知识点

#### 1. 数据库连接设置

+ 哪些知识点还不是很清楚呢？

  ```sql
  -c mean command "SQL"
  -f file.sql
  \i file.sql 恢复
  ```

+ ```sql
  -- 默认是查看全局连接数
  show max_connections --一般不能set修改
  ```

+ ```sql
  -- 指定数据库连接数 pg_database 
  select * from pg_database limit 1;
  select datname,datconnlimit from pg_database where datname = 'dbname';
  ```

+ ```sql
  -- 指定查看最大连接数 系统视图 pg_roles pg_user
  ```
  
+ 

#### 2. 用户权限管理和使用

#### 3. 安全策略

##### 3.1 行级访问控制 

```sql
alter row level security policy rls on table to username using(id =2 or id =2);

grant select on tablename to username;

alter table tablename enable row level security;

create row level security policy tls_1 on tablename to username using(id=1);
```

```sql
-- create table t_test
create table t_test(id int,name varchar(20));

insert into t_test values(1,'name'),(2,'username');

create row level security policy rlspname on t_test to user3 using(id = 1)
for + 场景或者是条件 for all(select,update, delete)[不含insert,for 场景后面要么接all,或者是select,update delete中的其中一个场景，不能同时接多个场景]
-- create for 场景和table确定后 不可修改？

-- 2. 修改行级访问控制 
alter row level security policy rlsname on tabmenaem to username using(??????)

create table t_user(id varchar(10),age int);

insert into t_user values('u1',20),('u2',50);

alter table t_user enable row level security;

create row level security policy rls2 on t_user to u1,u2 for select using(id = current_user);

create row level security policy rls2 on t_user for select to u1,u2 using(id = current_user);

grant select on t_user to u1,u2;

\c - u1

select * from t_user;

\c - u2 

select * from t_user; -- 作用于哪个用户


su - omm
\c - omm


grant all on t_user to u2;

\c - u2

create row level security policy rls3 on t_user to u2 using(id = current_user and age >=30);

\c - omm
create row level security policy rls3 on t_user to u1 using(age >=30); --满足其中一个就行？

```



##### 3.2 审计策略

```sql

传统审计，改参数

pg_settings
show audit_enabled

统一审计
select * from pg_settings where name like '%policy%';

考试时，有配置管理页面

create resource label label_t1 add table(t_user);

create audit policy adt1 privileges/access

create audit policy adt1 privileges create,alter on label() filter on ip() app(),app(),roles()

gs_auditing select * from gs_auditing


```

##### 3.3 脱敏策略

```sql
-- 1. 脱敏也会受到audit策略影响，也要绑定资源标签

create resource label lab_name add column(public.tablename.colname);
## 绑定
create masking policy --> \h create masking 


第一种
create masking policy mask1 maskall label(label_name);
select * from gs_masking
select * from t_test

insert into t_tes values(4,'123-123-45678'),(5,'');
alter masking policy mask1 add/modiry creditmasking on label(lab_name);

modiry

select * from t_test;
```

```sql
-- 1. create resource label for column of specified table
-- maybe should declacre schema like schemaname.tablename.colname
-- 
create resource label lab_name add column(tablename.colname);
-- 2. create masking policy policyname
create masking policy policy_name maskall randommasking creditcardmasking 
basicemailmasking
fullmailmasking
-- 3.create masking policy mask1 maskall on label(labelname)
select * from gs_masking -- 查看脱敏策略
select * from t_test
insert into values(4,'425-645-89413'),(5,'123-345-45678');
-- 一般作用于字符串类型
alter masking policy mask1 add creditcardmasking on label(lab_name);
-- 如果modify之前对同一表作了过多的masking policy的创建，应该先删除，
-- 再modify
alter masking policy mask1 modify regexmasking('[0-9]','-',7,9) on label(lab_name)

-- alter --- add remove /modify(替换)
-- select * from t_test;

alter masking policy mask1 modify (filter on roles()，ip('/24')); -- 替换
alter masking policy mask1 drop filter; -- 移除

alter masking policy mask1 comments ""
alter masking policy mask1 disable

\h alter audit
insert into t_test values(102541,'102541');

create resource label lab_id add column(t_test.id);

create masking policy  mask2 creditcardmasking on label(lab_id);

crop masking policy mask1;

create masking policy mask2 creditcardmasking on label(lab_id);

select * from gs_masking;

select * from t_test;

```

##### 3.4 账本数据库

```sql
账本数据库-- 防篡改
with blockchain
\dn

-- schemas 1. 不存在  2. 没有对象？ 
create schema s1 with blockchain;

create table s1.t1(c1 int);

-- 1. 系统给当前表新增hash列
-- 2. 创建新的一张历史表，在blockchain下面 s1_t1_hist
-- 3. 将当前表的操作绑定到全局表gs_global_chain,全部账本表共享共用？

-- 表是有要求的
a. 不能是列存表，不能是ustore类型，不能是临时表，不能是Mot表，不能是内存优化表

只能普通行存磁盘表


create schema s2 with blockchain;


create table s2.t2(c1 int);

-- select 
\d 

select * from s2.t2;

select *,hash from s2.t2;

insert into s2.t2 values(1),(2);

select *,hash from s2.t2;

hash: 作用

select * from blockchain.s2_t2_hist;

1. 创建
2. 查询
3. 检验一致性
select * from ledger_hist_check(schemaname,tablename);
select * from ledger_gchain_check(schemaname,tablename);
4. 修复被篡改的表
select * from ledger_hist_repair(schemaname,tablename);
select * from ledger_gchain_repari(schemaname,tablename);

```

#### 4. 存储过程

```sql
create or replace procedure name() as 
declare cursor cur1 is select * from tablename;
begin	
	for i in cur1 loop
		raise notice '%-%...',i.col1,i.col2
end;
/

create or replace procedure name() as 
declare cursor cur1 is select * from table; 
begin 
-- 没有恢复
-- 同名存储过程覆盖
	for i in cur1 loop
		raise notice '%-%-%..' ,i.col1,i.col2....i.coln
	end loop;
end;
/
call 存储过程
select 函数
-- 传递的参数名不要和表的字段相同
-- procedure 列表 inout的办法
DBE_OUTPUT_PRINT_LINE(concat(i.name,'----',i.cole ))

-- 明白原理很重要

create or replace procedure pirnt_demo() as 
先定义cursor 
declare cursor cur1 is 
select * from tablename;
begin
	for i in cur1 loop
		-- raise notice concat(i.c1,'---',i.age::varchar);
		raise notice '%--%',i.id,i.age;
		-- %字段占位符号，参数占位符号
	end loop;
end;
/ -- concat 慎用

-- 简洁的用法，用隐式
create or replace procedure print_info() as 
begin
	for i (select * from tablename) loop
		raise notice '%--%',i.id,i.age;
	end loop;
end; + Enter
/

-- 无限循坏
create or replace procedure if_case_demo() as
declare a int;
declare b int;
begin
a = 1;
b = 2;
if a > b then 
raise notice 'true';
else 
raise notice 'false';
end if;
end;
/
call if_case_demo()

create or replace procedure if_case_demo(a int,b int,c out int) as 
begin
if a>b then
	c = a;
	else if a = b then
	c = 0;
	end if;
end if;
end;
/
-- if end if 难用呀，有点不习惯

(if .... end if)

(case when ... end)

都用括号来包裹一下，更清晰，逻辑性更强

-- for 使用方法
for i in 1..10 loop -- [1,10] 是个闭区间
for i in (查询结果集) loop end loop; -- 循环遍历查询结果集合
for i in cursorname loop end loop; -- 可以将cursorname当作结果集
	
end loop;

for i in (generate_serial(10000)) loop
end loop;

create or replace procedure while_demo()
as
declare a int;
a = 1;
begin
while (a < 10) loop
	raise notice '%',a;
	a = a + 1;
end loop;
end;
/

create or replace procedure while_demo()
as
declare a int;
a = 1;
begin
while true loop
	raise notice '%',a;
	a = a + 1;
	if (a > 10) then exist;  
	end if;
end loop;
end;
/
```

#### 5. 触发器

#### 6. 数据库性能优化

```sql
-- 1. sql应用
索引的而应用，通过配置索引加速查询效率
analyze analyse 收集统计信息 analyze tablename(c1,c2);
select * from gs_index_advise('sql语句');
创建索引 根据推荐的列创建索引
create index index_name on tablename(c1,c2..cn);
()

explain analyze select /*tablescan(tablename)*/* from tablename where c1 = '' and c2 = '';

explain analyze select
explain analyze select 
explain analyze select /** /* from tablename where 

set cpu_index_tuple_cost = 100000;

alter index indexname unusable;

-- 2. SQL 改写从而加速查询  这个有点难哈。。。。。
 a.尽量将outer join转换成join
 b.not in 转换成 not exists
 c. union --> union all
 d. 避免隐式转换
 e. 避免子查询
```

#### 7. 论述题目讲解

#### 8. 实验总结

```sql
-- 1. 实验手册也是要学习的哦
-- 2. 操作系统的安装
-- 3. openGauss的安装
-- 4. 抓紧时间学习哦！！！！！

-- 第一阶段
1. SQL 基础语法 20%-40%
2. SQL练习题目
3. 真题练习，总共9套

重点 SQL基础 触发器和游标 
    安全审计
 分析每类题目
1. 数据库对象管理及SQL应用 20-40
    1~8个小问，递进或者是依赖关系，至少2分
2. 数据库连接和用户及权限管理 10-20；
    1~9问递进或者是依赖关系
3. 安全审计和行级访问控制 10-20分
4. 存储过程、触发器、游标
5. 性能调优 20分
    3~5问 性能优化
6. 论述题讲解，
	一般是2问，备份恢复或者是性能优化

机试要注意的内容

3.220版本
看文档是可以看的
打开SQL执行记录
不要覆盖，不要覆盖，不要覆盖
```

####  SQL直播练习

##### 重点SQL

```sql
-- 1. SQL
select * from (select *,dense_rank() over(partition  by cno order by score desc) as rk from student) where rk<=3
-- 2. 系统表1
a. 方法1：
select tablename,schemaname from pg_table where tablename = 'tablename';
b. 方法2：
select t1.relname,t2.nspname from pg_class t1 join pg_namespace t2 on t1.relnamespace = t2.oid where relname = 'tablename';
-- 3. 系统表2 查询表所在节点的nodeoids信息

select (relname,nodeoids) from pg_class t1,pgxc_class t2,pg_namespace t3 where t1.oid = t2.pcrelid and t1.relnamespace = t3.oid where relname = 'tablename' and t3.nspname = 'schemaname';

-- 4. 查询表所在的节点实例信息

select t4.* from pg_class t1,pgxc_class t2,pg_namespace t3,pgxc_node t4 
where t1.oid = t2.pcrelid and t1.relnamespace = t3.oid 
and cast(t2.nodeoids::varchar) = cast(t4.oid::varchar) and t1.relname = 'tablename' and t3.nspname = 'schemaname'

-- 5. 将某表的权限给指定指定用户，记得先给该表所在的schema权限给用户
grant usage on schema schemaname to somebody;
grant usage on schema schemaname to somebocy;
grant usage on schema schemaname to somebody;

create user username with auditadmin passwod '';
-- 考试时切换用户在右上角切换。。。。
-- 6. 将用户角色权限给其他用户，并允许其他用户继承权限可以授予其他角色或者用户
grant somebody/somerole to anotheruser/anotherrole with admin option;

create user user3 password 'Huawei@123' valid begin '' valid until ''; 

-- 7. 创建行访问策略，当前用户只有查看用户自身的数据
-- 错误
create resource label rls_all_data on table(all_data)
create row level security policy rlsp_name on label(rls_all_data) using(id=current_user);

-- 正确答案 
create row level security policy rlsp_name on all_data using(role = current_user);

--> create row level security policy policyname on tablename using();
alter table tablename disable row level security;

```



```sql
-- 1-5
create or replace function FUNC_SUM(stuid int) returns integer as 
$$
declare sum_grade int;
begin
select sum(grade) into sum_grade from elective group by sno where sno = stuid;
return sum_grade;
end;
$$language plpgsql;

-- check result:
hcie1=# call FUNC_SUM(1);
 func_sum
----------
      178
(1 row)

hcie1=# call FUNC_SUM(2);
 func_sum
----------
      192
(1 row)

hcie1=# call FUNC_SUM(3);
 func_sum
----------
      166
(1 row)

hcie1=# select sno,sum(grade) from elective group by sno;
 sno | sum
-----+-----
   1 | 178
   3 | 166
   2 | 192
(3 rows)

(3) 创建触发器DELETE_ELE,在STUDENT表上绑定触发器DELETE_ELE，在删除表中某个学生时，将ELECTIVE表中该学生的选课记录一并删除
-- 先创建procedure
create or replace function delete_info() returns trigger as
$$
begin
	delete from elective where sno = old.sno;
	return old;
end;
$$language plpgsql;

create trigger DELETE_ELE before delete on STUDENT for each row execute procedure delete_info();
```



```sql
-- 1-6
-- 创建存储过程pro_curs_1,使用游标打印各部门总人数，按照人数降序排序，
-- 打印格式如下:
-- 部门名称1---人数
-- 部门名称2---人数
-- 打印操作可以使用DBE_OUTPUTPRINT_LINE(outputstr)接口

create or replace procedure pro_curs_1() as 
declare cursor curname is select d.name,count(*) from teacher t  join department d on d.id = t.deptno group by d.name;
begin
	for i in curname loop
		raise notice '%---%',i.name,i.count;
	end loop;
end;

-- (2) 创建存储过程pro_curs_2,
-- 使用游标读取薪水按降序排序的前三位老师和后三位老师的信息，
-- 分别获取ID，姓名，部门名称，薪水和职称，请按以下格式打印ID-姓名-部门名称-薪水-职称

select t.id,t.name,d.name,t.salary,t.title from teacher t,department d where t.deptno = d.id order by t.salary desc limit 3;

select t.id,t.name,d.name,t.salary,t.title from teacher t,department d where t.deptno = d.id order by t.salary limit 3;


create or replace procedure pro_curs_2() as 
declare cursor curname is (select t.id,t.name tn,d.name dn,t.salary,t.title from teacher t,department d where t.deptno = d.id order by t.salary desc limit 3) union all(select t.id,t.name tn,d.name dn,t.salary,t.title from teacher t,department d where t.deptno = d.id order by t.salary limit 3);
begin
	for e in curname loop
		raise notice '%-%-%-%-%', e.id,e.tn,e.dn,e.salary,e.title;
	end loop;
end;
/

-- create table 
create table TEACHER(
	ID INTEGER NOT NULL,
    NAME VARCHAR(50) NOT NULL,
	DEPTNO INTEGER NOT NULL,
    SALARY FLOAT NOT NULL,
    TITLE VARCHAR(100) NOT NULL --职称：讲师、副教授、教授
)

create table DEPARTMENT(
	ID INTEGER NOT NULL,
    NAME VARCHAR(50) NOT NULL);
   
create table TEACHER(
	ID INTEGER NOT NULL,
    NAME VARCHAR(50) NOT NULL,
	DEPTNO INTEGER NOT NULL,
    SALARY FLOAT NOT NULL,
    TITLE VARCHAR(100) NOT NULL
);
```

```sql
-- 2-2 权限
-- 查看用户user1和数据库相关权限，要求查看显示库表名，用户名和数据库的权限 
-- 库表名  datname   
-- 用户名  aclexplode(datacl).grantee  
-- 库的权限 aclexplode(datacl).privilege_type
-- from pg_database
-- 过滤条件是 

-- 2-4 查询用户user1的表权限，要求显示表名、schema表、用户名、相关权限
-- 查询表 information_schema.table_privileges;
-- information_schema.table_privileges 
-- information_schema.table_privileges

create database dbname connection limit xxxxx;

select datname,datconnlimit from pg_database where datname = 'postgres';

alter database dbname connection limit newnumberof connection;

-- 2-4-2 为col1列设置脱敏策略，使用maskall函数对col1列进行数据脱敏

-- create resource label rls_name on table(tablename);

-- create masking policy mp_name add maskall on table(tablename.col1)

-- 正确的写法

create resource label rls_name add column(tablename.col1);

create masking policy maskname maskall on label(rls_name);

alter masking policy maskname comments 'xxxxx'; -- 不要忘记加comments


create resource label rls_name_2 add column(tablename.col2);

alter masking policy maskname add randommasking on label(rls_name_2);

alter masking policy maskname remove randommasking on label(rls_name_2);

```

#### 动态脱敏

##### 1. 创建用户dev_mask,bob_mask

```sql
create user dev_mask password 'Huawei@123';
create user bob_mask password 'Huawei@123';
```

##### 2. 创建表tb_for_masking,字段信息包含(col1 text,col2 text,col3 text);

```sql
create table tb_for_masking(col1 text,col2 text,col3 text);
```

##### 3. 为col1列创建脱敏策略maskpol1，使用maskall函数对col1进行数据脱敏

```sql
-- 1. 首先创建资源标签
create resource label rls_maskpol1 add column(tb_for_masking.col1);
-- 2. 创建脱敏策略
create masking policy maskpol1 maskall on label(rls_maskpol1);
```

##### 4. 为maskpol1脱敏策略添加描述信息"masking policy for tb_for_masking.col1"

```sql
alter masking policy maskpol1 comments 'masking policy for tb_for_masking.col1';
```

##### 5. 为maskpol1脱敏策略在原基础上增加以col2列做随机脱敏，脱敏函数使用randommasking

```sql
create resource label rls_maskpol2 add column(tb_for_masking.col2);
alter masking policy maskpol1 add randommasking on label(rls_maskpol2);
```

##### 6. 修改maskpol1移除col2列上的randommasking脱敏方式

```sql
alter masking policy maskpol1 remove randommasking on label(rls_maskpol2);
```

##### 7. 修改maskpol1这个脱方式，将在col1列的maskall修改为randommasking脱敏

```sql
alter masking policy maskpol1 modify randommasking on label(rls_maskpol1);
```

##### 8. 修改脱敏策略maskpol1使之仅对用户dev_mask和bob_mask,客户端工具为psql和gsql,IP地址为'10.20.30.40','127.0.0.0/24'场景生效；

```sql
alter masking policy maskpol1 modify(filter on roles(dev_mask,bob_mask),app(psql,gsql),ip('10.20.30.40','127.0.0.0/24'));
```

##### 9. 修改脱敏策略maskpol1,使之对所有用户场景生效

```sql
alter masking policy maskpol1 drop filter;
```

##### 10. 禁用脱敏策略

```sql
alter masking policy maskpol1 disable;
```






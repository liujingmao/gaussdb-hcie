### 知识点

#### 1. 数据库连接设置

+ 哪些知识点还不是很清楚呢？

  ```sql
  -c mean command "SQL"
  -f file.sql
  \i file.sql 恢复
  ```

+ ```sql
  -- 默认是查看全局连接数
  show max_connections --一般不能set修改
  ```

+ ```sql
  -- 指定数据库连接数 pg_database 
  select * from pg_database limit 1;
  select datname,datconnlimit from pg_database where datname = 'dbname';
  ```

+ ```sql
  -- 指定查看最大连接数 系统视图 pg_roles pg_user
  ```
  
+ 

#### 2. 用户权限管理和使用

#### 3. 安全策略

##### 3.1 行级访问控制 

```sql
alter row level security policy rls on table to username using(id =2 or id =2);

grant select on tablename to username;

alter table tablename enable row level security;

create row level security policy tls_1 on tablename to username using(id=1);
```

```sql
-- create table t_test
create table t_test(id int,name varchar(20));

insert into t_test values(1,'name'),(2,'username');

create row level security policy rlspname on t_test to user3 using(id = 1)
for + 场景或者是条件 for all(select,update, delete)[不含insert,for 场景后面要么接all,或者是select,update delete中的其中一个场景，不能同时接多个场景]
-- create for 场景和table确定后 不可修改？

-- 2. 修改行级访问控制 
alter row level security policy rlsname on tabmenaem to username using(??????)

create table t_user(id varchar(10),age int);

insert into t_user values('u1',20),('u2',50);

alter table t_user enable row level security;

create row level security policy rls2 on t_user to u1,u2 for select using(id = current_user);

create row level security policy rls2 on t_user for select to u1,u2 using(id = current_user);

grant select on t_user to u1,u2;

\c - u1

select * from t_user;

\c - u2 

select * from t_user; -- 作用于哪个用户


su - omm
\c - omm


grant all on t_user to u2;

\c - u2

create row level security policy rls3 on t_user to u2 using(id = current_user and age >=30);

\c - omm
create row level security policy rls3 on t_user to u1 using(age >=30); --满足其中一个就行？

```



##### 3.2 审计策略

```sql

传统审计，改参数

pg_settings
show audit_enabled

统一审计
select * from pg_settings where name like '%policy%';

考试时，有配置管理页面

create resource label label_t1 add table(t_user);

create audit policy adt1 privileges/access

create audit policy adt1 privileges create,alter on label() filter on ip() app(),app(),roles()

gs_auditing select * from gs_auditing


```

##### 3.3 脱敏策略

```sql
-- 1. 脱敏也会受到audit策略影响，也要绑定资源标签

create resource label lab_name add column(public.tablename.colname);
## 绑定
create masking policy --> \h create masking 


第一种
create masking policy mask1 maskall label(label_name);
select * from gs_masking
select * from t_test

insert into t_tes values(4,'123-123-45678'),(5,'');
alter masking policy mask1 add/modiry creditmasking on label(lab_name);

modiry

select * from t_test;
```

```sql
-- 1. create resource label for column of specified table
-- maybe should declacre schema like schemaname.tablename.colname
-- 
create resource label lab_name add column(tablename.colname);
-- 2. create masking policy policyname
create masking policy policy_name maskall randommasking creditcardmasking 
basicemailmasking
fullmailmasking
-- 3.create masking policy mask1 maskall on label(labelname)
select * from gs_masking -- 查看脱敏策略
select * from t_test
insert into values(4,'425-645-89413'),(5,'123-345-45678');
-- 一般作用于字符串类型
alter masking policy mask1 add creditcardmasking on label(lab_name);
-- 如果modify之前对同一表作了过多的masking policy的创建，应该先删除，
-- 再modify
alter masking policy mask1 modify regexmasking('[0-9]','-',7,9) on label(lab_name)

-- alter --- add remove /modify(替换)
-- select * from t_test;

alter masking policy mask1 modify (filter on roles()，ip('/24')); -- 替换
alter masking policy mask1 drop filter; -- 移除

alter masking policy mask1 comments ""
alter masking policy mask1 disable

\h alter audit
insert into t_test values(102541,'102541');

create resource label lab_id add column(t_test.id);

create masking policy  mask2 creditcardmasking on label(lab_id);

crop masking policy mask1;

create masking policy mask2 creditcardmasking on label(lab_id);

select * from gs_masking;

select * from t_test;

```

##### 3.4 账本数据库

```sql
账本数据库-- 防篡改
with blockchain
\dn

-- schemas 1. 不存在  2. 没有对象？ 
create schema s1 with blockchain;

create table s1.t1(c1 int);

-- 1. 系统给当前表新增hash列
-- 2. 创建新的一张历史表，在blockchain下面 s1_t1_hist
-- 3. 将当前表的操作绑定到全局表gs_global_chain,全部账本表共享共用？

-- 表是有要求的
a. 不能是列存表，不能是ustore类型，不能是临时表，不能是Mot表，不能是内存优化表

只能普通行存磁盘表


create schema s2 with blockchain;


create table s2.t2(c1 int);

-- select 
\d 

select * from s2.t2;

select *,hash from s2.t2;

insert into s2.t2 values(1),(2);

select *,hash from s2.t2;

hash: 作用

select * from blockchain.s2_t2_hist;

1. 创建
2. 查询
3. 检验一致性
select * from ledger_hist_check(schemaname,tablename);
select * from ledger_gchain_check(schemaname,tablename);
4. 修复被篡改的表
select * from ledger_hist_repair(schemaname,tablename);
select * from ledger_gchain_repari(schemaname,tablename);

```

#### 4. 存储过程

```sql
create or replace procedure name() as 
declare cursor cur1 is select * from tablename;
begin	
	for i in cur1 loop
		raise notice '%-%...',i.col1,i.col2
end;
/

create or replace procedure name() as 
declare cursor cur1 is select * from table; 
begin 
-- 没有恢复
-- 同名存储过程覆盖
	for i in cur1 loop
		raise notice '%-%-%..' ,i.col1,i.col2....i.coln
	end loop;
end;
/
call 存储过程
select 函数
-- 传递的参数名不要和表的字段相同
-- procedure 列表 inout的办法
DBE_OUTPUT_PRINT_LINE(concat(i.name,'----',i.cole ))

-- 明白原理很重要

create or replace procedure pirnt_demo() as 
先定义cursor 
declare cursor cur1 is 
select * from tablename;
begin
	for i in cur1 loop
		-- raise notice concat(i.c1,'---',i.age::varchar);
		raise notice '%--%',i.id,i.age;
		-- %字段占位符号，参数占位符号
	end loop;
end;
/ -- concat 慎用

-- 简洁的用法，用隐式
create or replace procedure print_info() as 
begin
	for i (select * from tablename) loop
		raise notice '%--%',i.id,i.age;
	end loop;
end; + Enter
/

-- 无限循坏
create or replace procedure if_case_demo() as
declare a int;
declare b int;
begin
a = 1;
b = 2;
if a > b then 
raise notice 'true';
else 
raise notice 'false';
end if;
end;
/
call if_case_demo()

create or replace procedure if_case_demo(a int,b int,c out int) as 
begin
if a>b then
	c = a;
	else if a = b then
	c = 0;
	end if;
end if;
end;
/
-- if end if 难用呀，有点不习惯

(if .... end if)

(case when ... end)

都用括号来包裹一下，更清晰，逻辑性更强

-- for 使用方法
for i in 1..10 loop -- [1,10] 是个闭区间
for i in (查询结果集) loop end loop; -- 循环遍历查询结果集合
for i in cursorname loop end loop; -- 可以将cursorname当作结果集
	
end loop;

for i in (generate_serial(10000)) loop
end loop;

create or replace procedure while_demo()
as
declare a int;
a = 1;
begin
while (a < 10) loop
	raise notice '%',a;
	a = a + 1;
end loop;
end;
/

create or replace procedure while_demo()
as
declare a int;
a = 1;
begin
while true loop
	raise notice '%',a;
	a = a + 1;
	if (a > 10) then exist;  
	end if;
end loop;
end;
/
```

#### 5. 触发器

#### 6. 数据库性能优化

```sql
-- 1. sql应用
索引的而应用，通过配置索引加速查询效率
analyze analyse 收集统计信息 analyze tablename(c1,c2);
select * from gs_index_advise('sql语句');
创建索引 根据推荐的列创建索引
create index index_name on tablename(c1,c2..cn);
()

explain analyze select /*tablescan(tablename)*/* from tablename where c1 = '' and c2 = '';

explain analyze select
explain analyze select 
explain analyze select /** /* from tablename where 

set cpu_index_tuple_cost = 100000;

alter index indexname unusable;

-- 2. SQL 改写从而加速查询  这个有点难哈。。。。。
```

#### 7. 论述题目讲解

#### 8. 实验总结

```sql
-- 1. 实验手册也是要学习的哦
-- 2. 操作系统的安装
-- 3. openGauss的安装
-- 4. 抓紧时间学习哦！！！！！

-- 第一阶段
1. SQL 基础语法 20%-40%
2. SQL练习题目
3. 真题练习，总共9套

重点 SQL基础 触发器和游标 
    安全审计
 分析每类题目
1. 数据库对象管理及SQL应用 20-40
    1~8个小问，递进或者是依赖关系，至少2分
2. 数据库连接和用户及权限管理 10-20；
    1~9问递进或者是依赖关系
3. 安全审计和行级访问控制 10-20分
4. 存储过程、触发器、游标
5. 性能调优 20分
    3~5问 性能优化
6. 论述题讲解，
	一般是2问，备份恢复或者是性能优化

机试要注意的内容

3.220版本
看文档是可以看的
打开SQL执行记录
不要覆盖，不要覆盖，不要覆盖
```

####  SQL直播练习





